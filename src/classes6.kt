
/*

    Kotlin 的扩展（Extension），主要分为两种语法：第一个是扩展函数，第二个是扩展属性。从语法上看，扩展看起来就像是我们从类的外部为它扩展了新的成员。
    什么是扩展函数和扩展属性？
    扩展函数，就是从类的外部扩展出来的一个函数，这个函数看起来就像是类的成员函数一样。这里，我们就以 JDK 当中的 String 为例，来看看如何通过 Kotlin 的扩展特性，为它新增一个 lastElement() 方法。

    // Ext.kt
    package com.boycoder.chapter06
*/
    /*
    ①    ②      ③            ④
    ↓     ↓       ↓            ↓      */
    fun String.lastElement(): Char? {
        //    ⑤
        //    ↓
        if (this.isEmpty()) {
            return null
        }

        return this[length - 1]
    }

    // 使用扩展函数
    fun main() {
        val msg = "Hello Wolrd"
        // lastElement就像String的成员方法一样可以直接调用
        val last = msg.lastElement() // last = d
    }

    //扩展函数的实现原理
/*
    public final class ExtKt {
        // ①
        public static final Character lastElement(String $this) {
        CharSequence var1 = (CharSequence)$this;
        if (var1.length() == 0) {
            return null
        }
    
        return  var1.charAt(var1.length() - 1);
        }
    }
    
    public static final void main() {
    String msg = "Hello Wolrd";
    //                        ②
    //                        ↓
    Character last = ExtKt.lastElement(msg);
    }
  */
    // 通过第一个注释，我们可以看到，原本定义在 String 类型上面的扩展函数 lastElement()，变成了一个普通的静态方法。另外，之前定义的扩展函数 lastElement() 是没有参数的，但反编译后的 Java 代码中，lastElement(String $this) 多了一个 String 类型的参数。还有第二个注释，这是扩展函数的调用处，原本 msg.lastElement() 的地方，变成了 ExtKt.lastElement(msg)。这说明，Kotlin 编写的扩展函数调用代码，最终会变成静态方法的调用。看到这里，也许你一下就能反应过来：Kotlin 的扩展函数只是从表面上将 lastElement() 变成 String 的成员，但它实际上并没有修改 String 这个类的源代码，lastElement() 也并没有真正变成 String 的成员方法。也就是说，由于 JVM 不理解 Kotlin 的扩展语法，所以 Kotlin 编译器会将扩展函数转换成对应的静态方法，而扩展函数调用处的代码也会被转换成静态方法的调用。

    //如何理解扩展属性？
    //在学习了 Kotlin 的扩展函数以后，扩展属性就很好理解了。扩展函数，是在类的外部为它定义一个新的成员方法；而扩展属性，则是在类的外部为它定义一个新的成员属性。
    //上面的两个箭头，说明了扩展函数与扩展属性，它们最终会被 Kotlin 编译器转换成静态方法；下面两个箭头，说明了扩展函数和扩展属性的调用代码，最终会被 Kotlin 编译器转换成静态方法的调用。
    // 所以也就是说，Kotlin 的扩展表面上看起来是为一个类扩展了新的成员，但是本质上，它还是静态方法。而且，不管是扩展函数还是扩展属性，它本质上都会变成一个静态的方法。那么，到底什么时候该用扩展函数，什么时候该用扩展属性呢？
    //其实，我们只需要看扩展在语义上更适合作为函数还是属性就够了。比如这里的 lastElement，它更适合作为一个扩展属性。这样设计的话，在语义上，lastElement 就像是 String 类当中的属性一样，它代表了字符串里的最后一个字符。


    //扩展的能力边界
    // 扩展能做什么？不能做什么？
    
    // 扩展能做什么
    // 当想从外部为一个类扩展一些方法和属性的时候，我们就可以通过扩展来实现。
    // Kotlin 当中，几乎所有的类都可以被扩展，包括普通类、单例类、密封类、枚举类、半生对象，甚至包含第三方提供的 Java 类。
    // 唯有内部匿名类，由于它本身不存在名称，我们无法指定 "接受者类型"，所以不能扩展。也没必要扩展。
    // Kotlin 的扩展类主要用途是来取代 Java 当中的各种工具类。所有 Java 工具类能做的事儿， Kotlin 扩展函数都可以做，并且可以做的更好。扩展函数的优势还在于，开发工具可以再编写代码的时候给出智能提示。

    // 扩展不能做什么
    // Kotlin 的扩展，本质上并没有修改接收者类型的源代码，所以它的行为是无法与“类成员”完全一致。
    // 第一个限制：
    // Kotlin 扩展不是真正的类成员，因此无法被它的子类重写。
    // 第二个限制：
    // 扩展属性无法存储状态，因为本身它是一个静态方法
    // 第三个限制：
    // 扩展的访问做英语仅限于两个地方。一，定义出的成员；二，接受者类型的公开成员。

    // 针对 Kotlin 的扩展的限制类说
    // 如果扩展是 “等层扩展”，那么扩展的访问与仅限于该 Kotlin 文件当中的所有成员，以及被扩展类型的公开成员，这种方式定义的扩展是可以被全局使用的。
    // 如果扩展式 被定义在某个类当中的。那么该扩展的访问与仅限于该类当中的所有成员。以及被扩展类型的公开成员。这种方式定义的扩展技能在该类当中使用。


    // 使用场景
    // 1: 主动使用扩展，通过他俩来优化软件架构
        // 对于复杂的类进行职责划分，关注点分离。让类的核心尽量简单易懂，而让类的功能属性与方法以扩展的形式存在于类的外部。
    // 2: 被动使用扩展，提升可读性与开发效率
        // 当我们无法修改外部的 SDK 时，对于重复的代码模式，我们以扩展的方式封装起来，提供给对应的接受者类型。 